<html>
  <head>
    <meta content='text/html;charset=UTF-8' http-equiv='Content-Type'>
    <title>OptiML &mdash; Getting started</title>
    <style type='text/css'>
      @import '../css/default.css';
      @import '../css/syntax.css';
    </style>
    <style media='print' type='text/css'>
      @import '../css/print.css';
    </style>
    <meta content='Delite documentation' name='subject'>
    <!-- <link href='images/favicon.png' rel='shortcut icon'> -->
  </head>
  <body>
    <div id='outer'>
      <div id='header'>
        <div class='home'><a href='http://stanford-ppl.github.com/Delite/optiml/' title="OptiML">OptiML</a></div>
      </div>
      <div id='menu'>
        <ol>
          <li>Start Here
            <ol>
              <li><a href='index.html'>Welcome</a></li>
              <li><a href='getting_started.html'>Getting Started</a></li>
              <li><a href="examples.html">Examples</a></li>
              <li><a href="faq.html">FAQ</a></li>
              <li><a href="debugging.html">Debugging</a></li>
              <li><a href="getting_started_native.html">Native Libraries and CUDA</a></li>
              <li><a href="http://groups.google.com/group/optiml">Mailing List</a></li>
              <li><a href="downloads/optiml-spec.pdf">Language Specification</a></li>
              <li><a href='http://stanford-ppl.github.com/Delite/index.html'>Delite</a></li>
            </ol>
          </li> 
          <!--
          <li>Reference
            <ol>
              <li><a href='api/0.3/index.html'>ScalaDoc API</a></li>
              <li>&nbsp;</li>
              <li><a href='sponsors.html'>Sponsors</a></li>
              <li class="logo"><a href="http://ppl.stanford.edu"><img width="110" alt="Stanford Pervasive Parallelism Lab" src='images/ppl_logo_small.png'></a></li>
            </ol>
          </li>
          -->
        </ol>
      </div>
      <div id='content'> 
        <h1 id='title_getting started'>Getting started</h1>
        <p style="font-size: 10pt"> The following instructions are for the Unix and OSX platforms. Windows support is coming soon.</p>

        <h2 id='title_from binary'>From Binary</h2>
        <p> <a href="downloads/optiml-0.3.2-alpha.tgz">Download the latest version of OptiML (0.3.2-alpha)</a> </p>
        <p> Extract the distribution: </p>
        <div class="highlight"><pre><code class="bash">tar -xzf optiml-0.3.2-alpha.tgz</code></pre></div>
        <p> Add OptiML to your path: </p>
        <div class="highlight"><pre><code class="bash">cd optiml-0.3.2-alpha
export PATH=$PWD/bin:$PATH</code></pre></div>
        <p> Run the OptiML REPL: </p>
        <div class="highlight"><pre><code class="bash">optiml</code></pre></div>

        <p> The first time you run the REPL, it will take a couple of minutes to download OptiML's dependencies. It will also take a short period to load OptiML 
        inside the REPL. Because OptiML is an embedded DSL inside Scala, the OptiML REPL is the Scala REPL with OptiML types and operations pre-loaded. To start playing,
        create a new DenseVector or new DenseMatrix: </p>

        <div class="highlight"><pre><code class="scala">val m = DenseMatrix.rand(10,10)
val v = DenseVector.rand(10)
v+v</code></pre></div>

        <p> Example applications are distributed with OptiML in the <code>apps</code> folder. To run an application, first we need to compile them: </p>
        <div class="highlight"><pre><code class="bash">sbt compile</code></pre></div>
        <p> Next, we can either run an interpreted version of our application directly, or <i>stage</i> it, to run DSL compilation and generate code for different targets.
        The interpreter version is just a pure Scala library that can be used to develop and prototype before switching to the Delite version for high performance.
        To run the interpreter version of logistic regression, run: </p>
        
        <div class="highlight"><pre><code class="bash">delitec LogRegInterpreter [input training data file] [input label file]</code></pre></div>

        <p> The logistic regression application is located in <code>apps/OptiML/src/LogReg.scala</code>. It expects a white-space delimited matrix of floating point values (one row per line) for
        the training data and a vector with one entry per line (either 0 or 1 representing the classification of the corresponding data element) as its input. </p>

        <p> To run the Delite version of the application, we first <i>stage</i> it using <code>delitec</code>, and then run it using <code>delite</code>: </p>

        <div class="highlight"><pre><code class="bash">delitec LogRegCompiler
delite LogRegCompiler [input training data file] [input label file] -t [num threads]
</code></pre></div>

        <p> You should notice that this version runs significantly faster than the interpreter version. To see the code that OptiML generated, look inside the <code>generated/</code> folder.
        With default arguments, we only attempt to generate parallel Scala kernels, which are located in <code>generated/scala/kernels</code>. Run </p>

        <div class="highlight"><pre><code class="bash">delitec --help
delite --help
</code></pre></div>

        <p> to see a list of options you can use when compiling and running the Delite high performance version of your application. 
        For example, to generate C++ kernels in addition to Scala kernels for logistic regression, we would use: </p>
        <div class="highlight"><pre><code class="bash">delitec LogRegCompiler --cpp
delite LogRegCompiler [input training data file] [input label file] --cpp [num threads]
</code></pre></div>

        <p> The generated C++ kernels will be located in <code>generated/cpp/kernels</code>. In order to use the C++ and CUDA code generators, the configuration files in <code>config/delite/</code> must have correct paths. </p>

        <p> Good luck and happy hacking! Contact us at <a href=mailto:optiml@googlegroups.com>optiml@googlegroups.com</a> if you have any questions or run into any problems. </p>


        <h2 id='title_from source'>From Source</h2>
        <p> Delite requires <a href="http://java.com">Java 1.6 or later</a>, <a href="http://python.org">Python 2.6</a>, <a href="http://git-scm.com">git</a> and <a href="http://www.scala-sbt.org/">SBT 0.12</a>. Instructions for installing
        these can be found at their respective websites. Be sure to increase the default heap size for your <code>sbt</code> executable script; a command that works well on most machines is:       
       <p><div class="highlight" style="overflow: scroll"><pre><code class="bash">java -Xmx4g -XX:MaxPermSize=1g -XX:ReservedCodeCacheSize=128m -jar `dirname $0`/sbt-launch.jar "$@"</pre></code></div></p>
        </p>
      <p>To get started, you first need to
        download the source for <code>virtualization-lms-core</code>, <code>Delite</code> and <code>Forge</code>. These three libraries provide 1) staging support to embed DSLs in scala, 2) a parallel and heterogeneous
        compiler, and 3) the meta DSL that Delite DSLs are implemented in, respectively. Delite uses <a href="http://git-scm.com/">git</a> for version control (see <a href="http://book.git-scm.com/2_installing_git.html">here</a> for installation instructions).</p>
      <p>
        First, make a copy of the repositories on your machine:
        </p><p>
        <div class="highlight"><pre><code class="bash">git clone https://github.com/TiarkRompf/virtualization-lms-core.git
git clone https://github.com/stanford-ppl/Delite.git 
git clone https://github.com/stanford-ppl/Forge.git</code></pre></div>         
        <p>Next, we need to compile each project and make them available to OptiML as a dependency. We'll start with LMS. From the same directory where we ran <code>git clone</code>, type </p> 
        <div class="highlight"><pre><code class="bash">cd virtualization-lms-core
git checkout delite-develop
sbt publish-local
</code></pre></div>

        <p> Now we are ready to compile Delite. Navigate back to the Delite directory and run: </p>
<div class="highlight" style="overflow: scroll"><pre><code class="bash">cd ../Delite
sbt update
sbt "; project framework; publish-local; project runtime; publish-local; project delite-test; publish-local"
export DELITE_HOME=$PWD
</code></pre></div>

        <p> We're almost done. Now we need to compile Forge, and run it to generate the most recent OptiML version: </p>
<div class="highlight"><pre><code class="bash">cd ../Forge
sbt update
export FORGE_HOME=$PWD
bin/update ppl.dsl.forge.dsls.optiml.OptiMLDSLRunner OptiML
</code></pre></div>

        <p>
        The OptiML distribution is now located in the directory <code>$FORGE_HOME/published/OptiML</code>. We can run applications from there, or copy this directory
        somewhere else (e.g. <code>~/OptiML</code>). For now, we'll assume we want to run from within the Forge directory tree (see <a href="https://github.com/stanford-ppl/Forge#using-an-existing-forge-dsl">the Forge instructions</a>
        for more detailed information on this setup).
        </p>        
        <p>        
        Now we are ready to write "hello world" in OptiML. Existing OptiML applications are located in the <code>apps/OptiML/src</code> directory from the root of the Delite repository. It is
        easiest to add your application here, but you can add it anywhere you want as long as you update the SBT configuration to point to your new location. For now, let's open up a file
        in <code>apps/OptiML/src</code> called 'HelloWorld.scala' and copy this text in:
        </p>
        <div class="highlight"><pre><code class="scala"><span class="k">import</span> <span class="nn">optiml.compiler._</span>
<span class="k">import</span> <span class="nn">optiml.library._</span>
<span class="k">import</span> <span class="nn">optiml.shared._</span>

<span class="k">object</span> <span class="nc">HelloWorldInterpreter</span> <span class="k">extends</span> <span class="nc">OptiMLApplicationInterpreter</span> <span class="k">with</span> <span class="nc">HelloWorld</span> 
<span class="k">object</span> <span class="nc">HelloWorldCompiler</span> <span class="k">extends</span> <span class="nc">OptiMLApplicationCompiler</span> <span class="k">with</span> <span class="nc">HelloWorld</span> 
<span class="k">trait</span> <span class="nc">HelloWorld</span> <span class="k">extends</span> <span class="nc">OptiMLApplication</span> <span class="o">{</span> 
  <span class="k">def</span> <span class="n">main() = println("</span><span class="s">hello world</span><span class="n">")</span>
<span class="o">}</span></pre></code></div>
        <p>
        OptiML comes with two versions: an interpreter, which is a pure Scala library implementation, and the compiler, which is the Delite implementation.
        All Delite applications have three phases: compiling (Scala), staging (DSL compilation), and executing (runtime). The first step, running the scala compiler,
        checks your application for syntactic and type correctness. Staging is where the main compilation happens: the DSL builds an IR of the program, optimizes it,
        and generates an execution graph along with code for multiple targets (e.g. Scala and CUDA). Finally, the Delite runtime reads in the execution graph and
        generated kernels and executes the application.
        </p>
        <p>
        Since Delite compilation can take a while (but produces high performance code), the recommended strategy is to use the OptiML interpreter while developing and
        prototyping, and then run the Delite version to scale out to larger datasets or heterogeneous hardware.
        </p>
        <p> So without further ado, let's get to it. Starting from the root of the Forge repository, first run the interpreter version: </p>
<p><div class="highlight" style="overflow: scroll"><pre><code class="bash">bin/update -s 3 -r HelloWorldInterpreter ppl.dsl.forge.dsls.optiml.OptiMLDSLRunner OptiML</code></pre></div></p>
        <p> If all went well, you should see <code>hello world</code> printed to the console! </p>
        <p> Now let's run the Delite version. Delite scripts require the JAVA_HOME environment variable to be set. If it is not already, you will need to set it: </p>
<div class="highlight"><pre><code class="bash">export JAVA_HOME=[absolute path of Java installation] </code></pre></div> 
        <p> Now we can run the compiler version simply by changing the parameters passed to the update script: </p>
        <p>
        <div class="highlight" style="overflow: scroll"><pre><code class="bash">bin/update -s 3 -d -r HelloWorldCompiler ppl.dsl.forge.dsls.optiml.OptiMLDSLRunner OptiML</code></pre></div> 
        </p><p>
        You should see output like the following:
        <div class="highlight"><pre><code class="bash">Delite Runtime executing with the following arguments:
HelloWorldRunner.deg
Delite Runtime executing with 1 CPU thread(s) and 0 GPU(s)
Beginning Execution Run 1
hello world
[METRICS]: Latest time for component all: 0.032000s
</code></pre></div>
      </p>
      <p>
      Congratulations! You just ran your first OptiML application. The generated execution graph will be in <code>published/OptiML/HelloWorldRunner.deg</code>. Also look around in the folder <code>published/OptiML/generated/</code> - it contains code OptiML generated!
      Take some time to look at the generated DEG file, and the generated kernels to see what went on behind the scenes.</p>

	  <p> Delite is capable of using CUDA to execute applications on the GPU as well as BLAS to accelerate certain matrix operations on the CPU.  These features require some additional setup in order to work with your environment. <a href="getting_started_native.html"> Click here for instructions.</a> </p>
      </div>
      <div id='footer'>Copyright &copy; 2011</div>
    </div>
  </body>
</html>
