<html>
  <head>
    <meta content='text/html;charset=UTF-8' http-equiv='Content-Type'>
    <title>Delite &mdash; My First DSL</title>
    <style type='text/css'>
      @import 'css/default.css';
      @import 'css/syntax.css';
    </style>
    <style media='print' type='text/css'>
      @import 'css/print.css';
    </style>
    <meta content='Delite documentation' name='subject'>
    <!-- <link href='images/favicon.png' rel='shortcut icon'> -->
  </head>
  <body>
    <div id='outer'>
      <div id='header'>
        <div class='home'><a href='http://stanford-ppl.github.com/Delite/' title="Delite">Delite</a></div>
      </div>
      <div id='menu'>
        <ol>
          <li>Start Here
            <ol>
              <li><a href='index.html'>Welcome</a></li>
              <li><a href="myfirstdsl.html">My First DSL</a></li>
              <li><a href="faq.html">FAQ</a></li>
              <!--
              <li><a href="performance.html">Performance</a></li>
              <li><a href="tests.html">Tests</a></li>
              <li><a href="troubleshooting.html">Troubleshooting</a></li>
              -->              
              <li><a href="publications.html">Publications</a></li>
            </ol>
          </li>
          <li>Getting it
            <ol>
            <!--
              <li><a href='releases.html'>Releases</a></li>
              <li><a href='snapshots.html'>Snapshots</a></li>
            -->
              <li><a href='source.html'>Source</a></li>
              <li><a href='license.html'>License</a></li>
            </ol>
          </li>
          <li>DSLs
            <ol>
              <li><a href='optiml/index.html'>OptiML</a></li>
              <li><a href='optiql/index.html'>OptiQL</a></li>
              <li><a href='optigraph/index.html'>OptiGraph></a></li>
            </ol>
          </li> 
          <!--
          <li>Reference
            <ol>
              <li><a href='api/0.3/index.html'>ScalaDoc API</a></li>
              <li>&nbsp;</li>
              <li><a href='sponsors.html'>Sponsors</a></li>
              <li class="logo"><a href="http://ppl.stanford.edu"><img width="110" alt="Stanford Pervasive Parallelism Lab" src='images/ppl_logo_small.png'></a></li>
            </ol>
          </li>
          -->
        </ol>
      </div>
      <div id='content'> 
        <h1 id='title_myfirstdsl'>My First DSL</h1>
        <p>A Delite DSL consists of a set of data types and operations. Delite DSLs are embedded in Scala, a host language designed
        to accomodate DSLs. Scala provides syntactic flexibility, an advanced type system with type inference, higher order functions,
        function currying, pattern matching, and lazy evaluation, among other features that allow library builders to develop powerful
        and easy to use abstractions. 
        </p>
        <p>
        Traditional embedded
        DSLs follow the 'just a library' approach: DSLs use these advanced features to provide syntactic sugar, but in the end are
        simply Scala applications compiled by the Scala compiler. Our approach, a collaboration with the Scala team at EPFL, takes DSL
        development another step forward. We want to take the best parts of the library approach - the free adoption
        of a parser, lexer and a type checker - and add to it the ability to build, optimize, and code generate from an intermediate
        representation (IR). In this way, we will transform sequential DSL code to heterogeneous, parallel code, capable
        of transparently running on different hardware devices. For more information about our techniques,
        please see <a href="publications.html">our publications</a>.
        </p>
        <p>
        In this example, we are going to design a very simple profiling DSL. The goal of this DSL is to make it easy to measure the
        time elapsed in different parts of an application. Here's an example of what we want to be able to do when we're finished:
        </p>
        <div class="highlight"><pre><code class="scala"><span class="k">val</span> time =
  profile (10) times {
    ... blah blah ...
  } report average
</code></pre></div>       
        <p>
        To make this DSL, we need to define at least three things: data structures,
        the nodes of our intermediate representation (IR), and the code generators for those nodes. Let's start with data structures.
        </p>
        <p>
        Our simple profiling DSL doesn't need much in the way of data. Let's just define a collection, an array, that contains the time
        elapsed for the last n runs. First, start from the base directory of the Delite distribution, and create a
        source directory for our project:
        </p>
        <div class="highlight"><pre><code class="bash">mkdir -p dsls/profiling/src</code></pre></div>
        <p>
        Now, let's define our array, which we'll call ProfileArray, in a package called "example.profiling.datastruct.scala".
        </p>
        <div class="highlight"><pre><code class="bash">mkdir -p dsls/profiling/src/example/profiling/datastruct/scala/</code></pre></div>
        <p>
        Write ProfileArray.scala inside the directory as follows:
        </p>
        <div class="highlight"><pre><code class="scala"><span class="k">package</span> <span class="nn">example.profiling.datastruct.scala</span>

<span class="k">class</span> <span class="nc">ProfileArray</span>(<span class="k">val</span> _numMeasurements: <span class="kt">Int</span>) {  
   <span class="k">val</span> _data = <span class="k">new</span> <span class="nc">Array[Double]</span>(_numMeasurements)
}
</code></pre></div>                                            
        <p>
        We've just defined the only data structure
        that we'll need for this example. Now we need to implement our DSL methods - but instead of implementing them directly, we want
        to build an intermediate representation. We are going to use the LMS library and Delite to do it. Open up a file called ProfileOps.scala
        inside <code>dsls/profiling/src/example/profiling</code>:      
        </p>
        <div class="highlight"><pre><code class="scala"><span class="k">package</span> <span class="nn">example.profiling</span>
<span class="k">import</span> <span class="nn">scala.virtualization.lms.common.{ScalaGenEffect, Base, EffectExp}</span>

<span class="c">// this is the abstract interface of our profiling methods</span>
<span class="k">trait</span> <span class="nc">ProfileOps</span> <span class="k">extends</span> <span class="nc">Base</span> {
  <span class="k">def</span> profile(n: <span class="kt">Rep[Int]</span>) = <span class="k">new</span> <span class="nc">ProfileOpsCls</span>(n)

  <span class="c">// syntax</span>
  <span class="k">class</span> <span class="nc">ProfileOpsCls</span>(n: <span class="kt">Rep[Int]</span>) {
    <span class="k">def</span> times(func: <span class="kt">=> Rep[Any]</span>) = profile_body(n, func)
  }
 
  <span class="c">// implementation</span>
  <span class="k">def</span> profile_body(n: <span class="kt">Rep[Int]</span>, func: <span class="kt">=> Rep[Any]</span>): <span class="kt">Rep[ProfileArray]</span>
}
</code></pre></div>
       <p> <code>Rep</code> is an <i>abstract type constructor</i>. Using this technique, applications are oblivious to the particular
       representation (which is actually bound only at compile time when all of the DSL traits are mixed together). Any operation on a <code>Rep[T]</code>
       we can override to do whatever want - or, as in this case, we can simply provide a method, <code>profile</code>, that takes a <code>Rep[Int]</code>,
       does something, and returns a <code>Rep[ProfileArray]</code>. The 'something' we are interested in is creating an IR node. We'll do that next,
       by expanding ProfileOps.scala to include an implementation of profile_body:
       </p>
       <div class="highlight"><pre><code class="scala"><span class="k">trait</span> <span class="nc">ProfileOpsExp</span> <span class="k">extends</span> <span class="nc">ProfileOps</span> <span class="k">with</span> <span class="nc">EffectExp</span> {
  <span class="k">case class</span> Profile(n: <span class="kt">Exp[Int]</span>, body: <span class="kt">Block[Any]</span>) <span class="k">extends</span> <span class="nc">Def[ProfileArray]</span>

  <span class="k">def</span> profile_body(n: <span class="kt">Exp[Int]</span>, func: <span class="kt">=> Exp[Any]</span>) = {
    reflectEffect(<span class="nc">Profile</span>(n, reifyEffects(func)))  <span class="c">// create an IR node</span>
  }

  <span class="k">override def</span> boundSyms(e: <span class="kt">Any</span>): <span class="kt">List[Sym[Any]]</span> = e <span class="k">match</span> {
    <span class="k">case</span> <span class="nc">Profile</span>(n, body) => effectSyms(body)
    <span class="k">case</span> _ => <span class="nc">super</span>.boundSyms(e)
  }  
}
</code></pre></div>
     <p>
     So far, so good. When an application uses our 'profile' method, we'll actually build an IR node and hand them back a representation
     of the type they were expecting. With type inference, they don't even have to be aware that they got a <code>Rep[ProfileArray]</code>
     instead of a real <code>ProfileArray</code>! We haven't shown how to generate code for <code>Profile</code> yet - we'll get to that
     soon. But first, let's finish our DSL op implementation: we need to define the report function for <code>ProfileArray</code>.
     Just like before, open up a file called ProfileArrayOps.scala inside <code>dsls/profiling/src/example/profiling</code>:
     </p>
     <div class="highlight"><pre><code class="scala"><span class="k">package</span> <span class="nn">example.profiling</span>
<span class="k">import</span> <span class="nn">reflect.{Manifest, SourceContext}</span>
<span class="k">import</span> <span class="nn">scala.virtualization.lms.common.{NumericOpsExp, FractionalOpsExp, Base}</span>
<span class="k">import</span> <span class="nn">scala.virtualization.lms.common.ScalaGenBase</span>
<span class="k">import</span> <span class="nn">ppl.delite.framework.ops.{DeliteCollectionOpsExp,DeliteOpsExp}</span>
<span class="k">import</span> <span class="nn">ppl.delite.framework.datastruct.scala.DeliteCollection</span>

<span class="k">trait</span> <span class="nc">ProfileArrayOps</span> <span class="k">extends</span> <span class="nc">Base</span> {
  <span class="c">// a simple way of enumerating choices in our syntax</span>
  <span class="k">class</span> <span class="nc">Reporter</span>
  <span class="k">object</span> <span class="nc">average</span> <span class="k">extends</span> <span class="nc">Reporter</span>
  <span class="k">object</span> <span class="nc">median</span> <span class="k">extends</span> <span class="nc">Reporter</span>

  <span class="c">// add report and length methods to Rep[ProfileArray]</span>
  <span class="k">def</span> infix_report(x: <span class="kt">Rep[ProfileArray]</span>, y: <span class="kt">Reporter</span>) = profile_report(x, y)
  <span class="k">def</span> infix_length(x: <span class="kt">Rep[ProfileArray]</span>) = profile_length(x)

  <span class="c">// implementation</span>
  <span class="k">def</span> profile_report(x: <span class="kt">Rep[ProfileArray]</span>, y: <span class="kt">Reporter</span>): <span class="kt">Rep[Double]</span>
  <span class="k">def</span> profile_length(x: <span class="kt">Rep[ProfileArray])</span>: <span class="kt">Rep[Int]</span>
}

<span class="k">trait</span> <span class="nc">ProfileArrayOpsExp</span> <span class="k">extends</span> <span class="nc">ProfileArrayOps</span> <span class="k">with</span> <span class="nc">NumericOpsExp</span>
  <span class="k">with</span> <span class="nc">FractionalOpsExp</span> <span class="k">with</span> <span class="nc">DeliteCollectionOpsExp</span> <span class="k">with</span> <span class="nc">DeliteOpsExp</span> {

  <span class="c">// a Delite parallel operation! was it really that easy?</span>
  <span class="k">case class</span> <span class="nc">ReportSum</span>(in: <span class="kt">Exp[ProfileArray]</span>) 
    <span class="k">extends</span> <span class="nc">DeliteOpReduce[Double]</span> {
      <span class="k">val</span> zero = unit(0.0)
      <span class="k">val</span> size = copyTransformedOrElse(_.size)(in.length)
      <span class="k">def</span> func = (a,b) => a + b
  }

  <span class="c">// median is a little trickier, let's just be sequential</span>
  <span class="k">case class</span> <span class="nc">ReportMedian</span>(in: <span class="kt">Exp[ProfileArray]</span>) <span class="k">extends</span> <span class="nc">Def[Double]</span>

  <span class="c">// length, apply, update need to reference the underlying data structure</span>
  <span class="k">case class</span> <span class="nc">ProfileLength</span>(in: <span class="kt">Exp[ProfileArray]</span>) <span class="k">extends</span> <span class="nc">Def[Int]</span>
  <span class="k">case class</span> <span class="nc">ProfileApply</span>(in: <span class="kt">Exp[ProfileArray]</span>, n: <span class="kt">Exp[Int]</span>) <span class="k">extends</span> <span class="nc">Def[Double]</span>
  <span class="k">case class</span> <span class="nc">ProfileUpdate</span>(in: <span class="kt">Exp[ProfileArray]</span>, n: <span class="kt">Exp[Int]</span>, y: <span class="kt">Exp[Double]</span>) 
    <span class="k">extends</span> <span class="nc">Def[Unit]</span>

  <span class="c">/////////////////////</span>
  <span class="c">// delite collection</span>

  <span class="k">def</span> isProfileArray[A](x: <span class="kt">Exp[DeliteCollection[A]]</span>) = x.isInstanceOf[<span class="kt">Exp[ProfileArray]</span>]
  <span class="k">def</span> asProfileArray[A](x: <span class="kt">Exp[DeliteCollection[A]]</span>) = x.asInstanceOf[<span class="kt">Exp[ProfileArray]</span>]

  <span class="k">override def</span> dc_size[A:Manifest](x: <span class="kt">Exp[DeliteCollection[A]]</span>)
    (<span class="k">implicit</span> ctx: <span class="kt">SourceContext</span>) = {

    <span class="k">if</span> (isProfileArray(x)) asProfileArray(x).length
    <span class="k">else super</span>.dc_size(x)
  }

  <span class="k">override def</span> dc_apply[A:Manifest](x: <span class="kt">Exp[DeliteCollection[A]]</span>, n: <span class="kt">Exp[Int]</span>)
    (<span class="k">implicit</span> ctx: <span class="kt">SourceContext</span>) = {

    <span class="k">if</span> (isProfileArray(x)) (profile_apply(asProfileArray(x),n)).asInstanceOf[<span class="kt">Exp[A]</span>]
    <span class="k">else super</span>.dc_apply(x,n)
  }

  <span class="k">override def</span> dc_update[A:Manifest](x: <span class="kt">Exp[DeliteCollection[A]]</span>, n: <span class="kt">Exp[Int]</span>, y: <span class="kt">Exp[A]</span>)
    (<span class="k">implicit</span> ctx: <span class="kt">SourceContext</span>) = {

    <span class="k">if</span> (isProfileArray(x)) profile_update(asProfileArray(x),n,y.asInstanceOf[<span class="kt">Exp[Double]</span>])
    <span class="k">else</span> super.dc_update(x,n,y)
  }

  <span class="k">def</span> profile_report(x: <span class="kt">Exp[ProfileArray]</span>, y: <span class="kt">Reporter</span>) = y <span class="k">match</span> {
    <span class="k">case</span> <span class="no">this.average</span> => <span class="nc">ReportSum</span>(x) / x.length   <span class="c">// inline</span>
    <span class="k">case</span> <span class="no">this.median</span> => <span class="nc">ReportMedian</span>(x)
    <span class="k">case</span> _ => <span class="k">throw new</span> <span class="nc">IllegalArgumentException</span>(<span class="s">"unknown report type"</span>)
  }
  <span class="k">def</span> profile_length(x: <span class="kt">Exp[ProfileArray]</span>) = <span class="nc">ProfileLength</span>(x)
  <span class="k">def</span> profile_apply(x: <span class="kt">Exp[ProfileArray]</span>, n: <span class="kt">Exp[Int]</span>): <span class="kt">Exp[Double]</span>
    = <span class="nc">ProfileApply</span>(x,n)
  <span class="k">def</span> profile_update(x: <span class="kt">Exp[ProfileArray]</span>, n: <span class="kt">Exp[Int]</span>, y: <span class="kt">Exp[Double]</span>) 
    = <span class="nc">ProfileUpdate</span>(x,n,y)
}
</code></pre></div>
     <p>
     That's all the IR definition we need! The only surprising piece here is the overrides for <code>dc_apply, dc_update, and dc_size</code>. <code>dc</code> here stands
     for "DeliteCollection". These methods are statically dispatched inside <code>DeliteOps</code>; they tell <code>DeliteOps</code> how to access the underlying data
     for a particular collection. We have just one more piece of the language left to implement:
     code generators. Luckily, the generators for Profile and ReportMedian are simple, and because
     ReportAverage is a DeliteOp, Delite takes care of that one for us! Let's start with the generator
     for Profile. Open ProfileOps.scala again, and add this snippet to the bottom:
     </p>
     <div class="highlight"><pre><code class="scala"><span class="k">trait</span> <span class="nc">ScalaGenProfileOps</span> <span class="k">extends</span> <span class="nc">ScalaGenEffect</span> {
  <span class="k">val</span> IR: <span class="kt">ProfileOpsExp</span>
  <span class="k">import</span> IR._

  <span class="k">override def</span> emitNode(sym: <span class="kt">Sym[Any]</span>, rhs: <span class="kt">Def[Any]</span>) = 
    rhs <span class="k">match</span> {
      <span class="c">// insert instrumentation code around function body</span>
      <span class="k">case</span> <span class="nc">Profile</span>(n, body) => 
        stream.println(<span class="s">"val " + quote(sym) + " = {"</span>)
        stream.println(<span class="s">"val out = new ProfileArray("</span> + quote(n) + <span class="s">")"</span>)
        stream.println(<span class="s">"var i = 0"</span>)
        stream.println(<span class="s">"while (i < "</span> + quote(n) + <span class="s">") {"</span>)
        stream.println(<span class="s">"  val start = System.currentTimeMillis()"</span>)
        emitBlock(body)
        stream.println(<span class="s">"  val end = System.currentTimeMillis()"</span>)
        stream.println(<span class="s">"  val duration = (end - start)/1000f "</span>)
        stream.println(<span class="s">"  out._data(i) = duration"</span>)
        stream.println(<span class="s">"  i += 1"</span>)
        stream.println(<span class="s">"}"</span>)
        stream.println(<span class="s">"out"</span>)
        stream.println(<span class="s">"}"</span>)

      <span class="k">case</span> _ => <span class="nc">super</span>.emitNode(sym, rhs)
    }
}
</code></pre></div>
    <p>
    That takes care of <code>Profile</code>. Now, similarly for ProfileArray:
    </p>
     <div class="highlight"><pre><code class="scala"><span class="k">trait</span> <span class="nc">ScalaGenProfileArrayOps</span> <span class="k">extends</span> <span class="nc">ScalaGenBase</span> {
  <span class="k">val</span> IR: <span class="kt">ProfileArrayOpsExp</span>
  <span class="k">import</span> IR._

  <span class="k">override def</span> emitNode(sym: <span class="kt">Sym[Any]</span>, rhs: <span class="kt">Def[Any]</span>) =
    rhs <span class="k">match</span> {
      <span class="k">case</span> <span class="nc">ReportMedian</span>(x) =>
        <span class="k">val</span> a = quote(x)
        <span class="k">val</span> size = a + <span class="s">"._numMeasurements"</span>
        stream.println(<span class="s">"val "</span> + quote(sym) + <span class="s">" = {"</span>)
        stream.println(<span class="s">"val d = new Array[Double]("</span>+size+<span class="s">")"</span>)
        stream.println(<span class="s">"System.arraycopy("</span>+a+<span class="s">"._data, 0, d, 0, "</span>+size+<span class="s">")"</span>)
        stream.println(<span class="s">"scala.util.Sorting.quickSort(d)"</span>)
        stream.println(<span class="s">"d(Math.ceil("</span>+size+<span class="s">"/2).asInstanceOf[Int])"</span>)
        stream.println(<span class="s">"}"</span>)
      <span class="k">case</span> <span class="nc">ProfileLength</span>(x) => emitValDef(sym, quote(x) + <span class="s">"._numMeasurements"</span>)
      <span class="k">case</span> <span class="nc">ProfileApply</span>(x,n) => emitValDef(sym, quote(x) + <span class="s">"._data("</span> + quote(n) + <span class="s">")"</span>)
      <span class="k">case</span> <span class="nc">ProfileUpdate</span>(x,n,y) => 
         emitValDef(sym, quote(x) + <span class="s">"._data("</span> + quote(n) + <span class="s">") = "</span> + quote(y))
      <span class="k">case</span> _ => <span class="nc">super</span>.emitNode(sym, rhs)
    }
}
</code></pre></div>
    <p> So close! We've finishing defining our entire DSL. Now we just need to put some machinery together
    so that applications can use it. In the same directory as ProfileOps.scala, open up a file called
    Profile.scala. Here, we're going to add package definitions and Delite hooks so that DSL applications
    can easily import our DSL into scope.
    </p>
    <div class="highlight"><pre><code class="scala"><span class="k">package</span> <span class="nn">example.profiling</span>
<span class="k">import</span> <span class="nn">scala.virtualization.lms.common._</span>
<span class="k">import</span> <span class="nn">scala.virtualization.lms.internal._</span>
<span class="k">import</span> <span class="nn">ppl.delite.framework._</span>
<span class="k">import</span> <span class="nn">ppl.delite.framework.codegen._</span>
<span class="k">import</span> <span class="nn">ppl.delite.framework.ops._</span>
<span class="k">import</span> <span class="nn">ppl.delite.framework.datastruct.scala.DeliteCollection</span>
<span class="k">import</span> <span class="nn">codegen.delite.overrides._</span>
<span class="k">import</span> <span class="nn">codegen.scala.TargetScala</span>
<span class="k">import</span> <span class="nn">java.io.File</span>

<span class="c">/* Profile DSL front-end types */</span>
<span class="k">abstract class</span> <span class="kt">ProfileArray</span> <span class="k">extends</span> <span class="kt">DeliteCollection[Double]</span>

<span class="c">/* Application packages */</span>
<span class="k">trait</span> <span class="nc">ProfileApplicationRunner</span> <span class="k">extends</span> <span class="nc">ProfileApplication</span> 
  <span class="k">with</span> <span class="nc">DeliteApplication</span> <span class="k">with</span> <span class="nc">ProfileExp</span>
<span class="k">trait</span> <span class="nc">ProfileApplication</span> <span class="k">extends</span> <span class="nc">Profile</span> <span class="k">with</span> <span class="nc">ProfileLift</span> {
  <span class="k">var</span> args: <span class="kt">Rep[Array[String]]</span>
  <span class="k">def</span> main(): <span class="kt">Unit</span>
}

<span class="k">trait</span> <span class="nc">ProfileLift</span> <span class="k">extends</span> <span class="nc">LiftScala</span> { <span class="c">// allow apps to use all of Scala</span>
  this: <span class="nc">Profile</span> =>
}

<span class="c">/* IR packages */</span>
<span class="k">trait</span> <span class="nc">Profile</span> <span class="k">extends</span> <span class="nc">ScalaOpsPkg</span> <span class="k">with</span> <span class="nc">ProfileOps</span> <span class="k">with</span> <span class="nc">ProfileArrayOps</span>
<span class="k">trait</span> <span class="nc">ProfileExp</span> <span class="k">extends</span> <span class="nc">Profile</span> <span class="k">with</span> <span class="nc">ScalaOpsPkgExp</span> <span class="k">with</span> <span class="nc">ProfileOpsExp</span>
  <span class="k">with</span> <span class="nc">ProfileArrayOpsExp</span> <span class="k">with</span> <span class="nc">DeliteOpsExp</span> <span class="k">with</span> <span class="nc">VariantsOpsExp</span> 
  <span class="k">with</span> <span class="nc">DeliteAllOverridesExp</span> {

  this: <span class="nc">DeliteApplication</span> <span class="k">with</span> <span class="nc">ProfileApplication</span> <span class="k">with</span> <span class="nc">ProfileExp</span> =>

  <span class="k">def</span> getCodeGenPkg(t: <span class="kt">Target</span>{<span class="k">val</span> IR: <span class="kt">ProfileExp.this.type</span>}):
    <span class="kt">GenericFatCodegen</span>{<span class="k">val</span> IR: <span class="kt">ProfileExp.this.type</span>} = {
    
    t <span class="k">match</span> {
      <span class="k">case</span> _:<span class="kt">TargetScala</span> => <span class="k">new</span> <span class="nc">ProfileCodeGenScala</span> {
        <span class="k">val</span> IR: <span class="kt">ProfileExp.this.type</span> = <span class="nc">ProfileExp.this</span>
      }
      <span class="k">case</span> _ => <span class="k">throw new</span> <span class="nc">IllegalArgumentException</span>(<span class="s">"unsupported target"</span>)
    }
  }
}

<span class="c">/* Code generator packages */</span>
<span class="k">trait</span> <span class="nc">ProfileCodeGenBase</span> <span class="k">extends</span> <span class="nc">GenericFatCodegen</span> <span class="k">with</span> <span class="nc">codegen.Utils</span> {
  <span class="k">val</span> IR: <span class="kt">DeliteApplication</span> <span class="k">with</span> <span class="kt">ProfileExp</span>
  <span class="k">override def</span> initialDefs = IR.deliteGenerator.availableDefs
  
  <span class="k">def</span> dsmap(s: <span class="kt">String</span>) = {
    <span class="k">var</span> res = s.replaceAll(<span class="s">"example.profiling.datastruct"</span>, <span class="s">"generated"</span>)
    res.replaceAll(<span class="s">"example.profiling"</span>, <span class="s">"generated.scala"</span>)
  }
  
  <span class="k">override def</span> remap[A](m: <span class="kt">Manifest[A]</span>): <span class="kt">String</span> = dsmap(super.remap(m))
  
  <span class="k">override def</span> emitDataStructures(path: <span class="s">String</span>) {
    <span class="k">val</span> s = File.separator
    <span class="k">val</span> dsRoot = Config.homeDir + s+<span class="s">"dsls"</span>+s+<span class="s">"profiling"</span>+s+<span class="s">"src"</span>+s+
                 <span class="s">"example"</span>+s+<span class="s">"profiling"</span>+s+<span class="s">"datastruct"</span>+s + <span class="nc">this</span>.toString

    copyDataStructures(dsRoot, path, dsmap)
  }
}

<span class="k">trait</span> <span class="nc">ProfileCodeGenScala</span> <span class="k">extends</span> <span class="nc">ProfileCodeGenBase</span> <span class="k">with</span> <span class="nc">ScalaCodeGenPkg</span> 
  <span class="k">with</span> <span class="nc">ScalaGenDeliteOps</span> <span class="k">with</span> <span class="nc">ScalaGenProfileOps</span> <span class="k">with</span> <span class="nc">ScalaGenProfileArrayOps</span>
  <span class="k">with</span> <span class="nc">ScalaGenVariantsOps</span> <span class="k">with</span> <span class="nc">ScalaGenDeliteCollectionOps</span> 
  <span class="k">with</span> <span class="nc">DeliteScalaGenAllOverrides</span> {
      
  <span class="k">val</span> IR: <span class="kt">DeliteApplication</span> <span class="k">with</span> <span class="kt">ProfileExp</span>
}
</code></pre></div>
    <p>
    This probably looks like a lot of voodoo - and indeed, there is a little. Check out the slides from
    <a href="http://cs442.stanford.edu">our DSL course</a> to learn more about the details. In general,
    we are
    <ol>
    <li> Defining abstract <i>front-end</i> language types that are independent from our back-end datastructures</li>
    <li> Defining separate packages for abstract operations, IR nodes and code generators </li>
    <li> Declaring which parts of Scala we want to allow DSL applications to use (in this case, everything) </li>
    <li> Telling Delite how to access our code generators </li>
    <li> Providing a utility method to map the data structure we defined earlier to one that will be used from generated code </li>
    </ol>
    </p>
    <p>
    Finally, our DSL is in place. Now we can write an application and test it! Let's call it HelloProfile.scala:
   <div class="highlight"><pre><code class="scala"><span class="k">import</span> <span class="nn">example.profiling._</span>
<span class="k">object</span> <span class="nc">HelloProfileRunner</span> <span class="k">extends</span> <span class="nc">ProfileApplicationRunner</span> <span class="k">with</span> <span class="nc">HelloProfile</span> 
<span class="k">trait</span> <span class="nc">HelloProfile</span> <span class="k">extends</span> <span class="nc">ProfileApplication</span> <span class="o">{</span> 
 
  <span class="k">def</span> <span class="n">main() = {
    <span class="k">var</span> acc = 0.
    <span class="k">val</span> time = 
      profile (100) times {
        for (i <- 0 until 100000) {
          acc += Math.exp(i)*Math.pow(i,10.0)*42.0
        }
      } report average
    println(<span class="s">"average loop time: "</span> + time)
  }
}
</span></code></pre></div>
    <p>
    Run it the same way we did in the <a href="optiml/getting_started.html">getting started guide</a>.
    You can use 'sbt' with it by adding the following line to project/Build.scala, inside
    the DSLs class:
    </p>
    <div class="highlight"><pre><code class="scala"><span class="k">lazy val</span> profiling = Project(<span class="s">"profiling"</span>, 
                              <span class="k">file</span>(<span class="s">"dsls/profiling"</span>), 
                              <span class="k">settings</span> = virtBuildSettings) 
                              <span class="k">dependsOn</span>(framework)</code></pre></div>
    and by updating the <code>dsls</code> project to include <code>profiling<code>:
    <div class="highlight"><pre><code class="scala"><span class="k">lazy val</span> dsls = Project(<span class="s">"dsls"</span>, 
                         <span class="k">file</span>(<span class="s">"dsls"</span>), 
                         <span class="k">settings</span> = virtBuildSettings) 
                         <span class="k">aggregate</span>(optila,optiml,optiql,profiling)</code></pre></div>
    <p>
    Note that you can add the profiling DSL to your classpath so that <code>delitec</code> can find it by opening up the file <code>bin/delitec</code> and adding <span class="s">profiling</span> to the list of DSLs:
    <div class="highlight"><pre><code class="bash">DSLs = [<span class="s">'optiml'</span>, <span class="s">'optila'</span>, <span class="s">'optiql'</span>, <span class="s">'profiling'</span>]</code></pre></div>
    </p>
    <p>
    Congratulations! You just built your first Delite DSL. Go try it out with some test apps!
    We've only scratched the surface though - Delite and LMS both offer many more features, including
    more DeliteOp types, a CUDA generator, cool optimizations, a system for managing side effects, and more.
    The best place to get started is to look at existing DSL code (such as OptiML code). You should start to see
    patterns emerge that you can use right away while you are becoming more familiar with the system.
    If you run into any problems, don't hesitate to check out the <a href="troubleshooting.html">troubleshooting page</a>, 
    or <a href="mailto:cs442-spr1011-staff@lists.stanford.edu">contact us</a>.
    </p>
     </div>
      <div id='footer'>Copyright &copy; 2012</div>
    </div>
  </body>
</html>
